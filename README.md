<div dir="rtl">
# Quality Assurance Course
## تابع Unit Testing

### 🧪 الخطوة 4) التشغيل محلياً ثم في CI (Run Locally & in CI)

بعد ما تكتب الاختبارات، شغّلها أولاً على جهازك **محلياً**.  
لما تتأكد إنها شغالة تمام، دمجها في نظام **CI/CD pipeline** (زي GitHub Actions أو Jenkins).  

هيك كل مرة حدا يعدل بالكود، الاختبارات بتشتغل **أوتوماتيكياً** لتتأكد إن ما انكسر شيء. 

### ✅ نصائح:
- خَلّي النتائج **مختصرة وواضحة**.  
- استخدم مبدأ **Fail Fast**: إذا في خطأ، خليه يوقف بسرعة بدل ما يكمّل عالفاضي.

   ### ملاحظاتي:
  - CI (continuous Integration) كل مبرمج بكتب كود على جهازه بعد الانتهاء بنرفع تلقائياً كل الاكواد على مثلا github وبتجمع الاكواد مع بعض عن طريق ال CI بعدين بتعمل فحص تلقائي

---

### 🧩 الخطوة 5) تشخيص الفشل، إصلاح، وإعادة هيكلة (Diagnose Failures, Fix, Refactor)

لما اختبار يفشل، أول شيء **حلّل السبب**:  
هل الخطأ من الكود نفسه؟ ولا من الاختبار؟  

بعدها:
- صلّح **مشكلة واحدة فقط في المرة الواحدة**.  
- لما تصير كل الاختبارات “خضراء” ✅، وقتها فيك تعيد **هيكلة الكود (Refactor)** بثقة.  
  الاختبارات هي درعك ضد الأخطاء الجديدة.  

---

### 🔁 الخطوة 6) إعادة التشغيل، المراجعة، والصيانة (Rerun, Review, Maintain)

بعد ما تعمل التعديلات، **شغّل كل الاختبارات مرة ثانية**.  
نظّف الكود والاختبارات:

- احذف الاختبارات المكررة أو غير المفيدة.  
- ميّز الاختبارات البطيئة لتشغيلها أقل.  
- راقب نسبة **Code Coverage** (كم من الكود مغطّى باختبارات).  

> ⚙️ تذكّر: الاختبارات نفسها تحتاج صيانة.  
> إذا صارت هشّة أو بطيئة، لازم تصلحها مثل أي كود ثاني.  

---

### 💡 نصائح سريعة (Pro Tips)

- خَلّي الاختبارات **سريعة ومستقلة**.  
- سمّيها بأسماء توضّح **السلوك المتوقع**، مش التفاصيل التقنية.  
  مثال: `test_total_includes_tax` بدل `test_calc1`.  
- إذا اختبارك أحيانًا ينجح وأحيانًا يفشل، اعتبره **Bug بنفسه** — فقد الموثوقية.  

---

.
> ### 🧠 What are the Different Unit Testing Techniques?

Unit tests are most effective when they mix **smart test design** with **sensible coverage goals**.  
الفكرة مش إنك توصل 100% تغطية (coverage) بأي ثمن، بل إنك **تركّز على الأجزاء المهمة والخطرة** من النظام.  
ببساطة:
- اعمل اختبارات **واسعة (breadth)** للأجزاء العامة.
- واعمق أكثر في الاختبار **أينما يوجد خطر أعلى** من الأخطاء.
- لا تقع في فخ "100% أو لا شيء" — الكمال الرقمي مش هدف حقيقي.

---

## 🎯 Main Unit Testing Techniques

تقنيات اختبار الوحدات عادةً تُقسم إلى ثلاثة أنواع رئيسية:

### ⚫ 1) Black Box Testing  
تركّز على **المدخلات والمخرجات** فقط دون معرفة كيف يعمل الكود من الداخل.  
يعني تتعامل مع الكود كأنه "صندوق أسود".  
مثلاً:  
لو عندك دالة تحسب ضريبة، تختبر إنها ترجع ناتج صحيح لأي مدخلات، بدون النظر إلى المعادلات بداخلها.  

> 🔹 مفيد لاختبار واجهات المستخدم أو وظائف محددة من منظور المستخدم.

---

### ⚪ 2) White Box Testing  
يعني إنك تختبر **من داخل الكود نفسه** — تعرف كيف الكود مكتوب وتبني اختبارات بناءً على مساراته المنطقية.  
تركّز على:
- تدفق البيانات (data flow)
- الشروط والفروع (conditions and branches)
- التكرارات (loops)

> 🔹 مفيد لاكتشاف أخطاء منطقية داخلية، أو أجزاء الكود التي لا تُنفّذ أبداً.

---

### ⚫⚪ 3) Gray Box Testing  
دمج بين النوعين السابقين.  
المختبر يعرف **بعض التفاصيل الداخلية**، لكن يختبر من **منظور خارجي جزئياً**.  
يُستخدم عادةً في:
- **اختبار التكامل (Integration testing)**  
- **تحليل المخاطر (Risk analysis)**  
- **اختبار الأداء** لبعض المكونات الداخلية.

> 🔹 يوازن بين الفهم الداخلي والدور الخارجي للمستخدم.

---

## 📊 Code Coverage in Unit Testing

**Code Coverage** مش هدف نهائي، بل أداة لتكشف وين عندك نقاط عمياء ما تم اختبارها.  
يعني بدل ما تلاحق رقم، استخدمها لتعرف أين ما زال الكود بدون اختبارات.

### الأنواع الأساسية للتغطية:

#### 🟢 1) Statement Coverage  
يتأكد إن **كل سطر كود** تم تنفيذه على الأقل مرة.

#### 🟡 2) Decision Coverage  
يتأكد إن **كل قرار منطقي (if / else)** تم اختباره في حالتيه (true/false).

#### 🔵 3) Branch Coverage  
يتأكد إن **كل فرع من فروع الكود** تم المرور عليه، حتى الفروع المتداخلة.

#### 🟣 4) Condition Coverage  
يتأكد إن **كل شرط فرعي داخل القرار** تم اختباره (مثلاً كل جزء من if (A && B)).

#### 🟠 5) Finite State Machine Coverage  
يُستخدم للأنظمة التي فيها **حالات متعددة وانتقالات (states & transitions)**، ويتأكد إن كل انتقال محتمل بين الحالات تم اختباره.

---

> 🧩 **الخلاصة:**  
> التغطية العالية ممتازة، لكن الأهم هو أن تكون **الاختبارات ذكية، تغطي ما يهم فعلاً، وتكشف الأخطاء قبل أن تصل للمستخدم.**
> <div dir="rtl">

## 🧩 ما هو دور الـ Mocking والـ Stubbing في اختبار الوحدات (Unit Testing)

في اختبار الوحدات، الهدف إنك تختبر **الوحدة البرمجية نفسها** بدون التأثر بأي تبعيات خارجية مثل قاعدة البيانات أو الشبكة أو نظام الملفات.  
وهون بيجي دور **Mocks** و**Stubs** — والمعروفين باسم **Test Doubles** — لاستبدال الكائنات الحقيقية مؤقتًا أثناء الاختبار.

---

## 🎯 لماذا نستخدم Test Doubles؟

الغاية منها **العزل (Isolation)** و**التحكم (Control)**، بحيث تكون اختباراتك دقيقة، سريعة، ويمكن إعادة تشغيلها بثبات.

- **العزل (Isolation):** تختبر الكود نفسه فقط بدون قاعدة بيانات أو API فعلي.  
- **الثبات (Determinism):** تتحكم بالنتائج حتى تكون متوقعة ومضمونة كل مرة.  
- **السرعة (Speed):** الاختبارات بتخلص بسرعة لأنك ما تتعامل مع أنظمة خارجية بطيئة.  
- **محاكاة الحالات النادرة (Edge Case Simulation):** تقدر تحاكي أخطاء زي انتهاء مهلة الـ API أو فشل الاتصال بسهولة.

---

## 🧱 الـ Stubs

الـ **Stub** هو نسخة مبسطة من كائن حقيقي، وظيفتها **إرجاع قيم جاهزة فقط**.  
ما بتسجل التفاعلات، بل تعطي رد ثابت لاختبار المنطق الداخلي للكود.

### 🧪 مثال (Python):

```python
def get_user_from_db(user_id):
    # تخيل هنا استدعاء فعلي لقاعدة البيانات
    raise NotImplementedError()

def test_returns_user_with_stub(monkeypatch):
    # Arrange: إنشاء stub بدلاً من قاعدة البيانات
    monkeypatch.setattr("app.get_user_from_db", lambda _: {"id": 1, "name": "Alice"})
    # Act
    user = get_user_from_db(1)
    # Assert
    assert user["name"] == "Alice"

<div dir="rtl">
```

## 🧰 أكثر أدوات اختبار الوحدات (Unit Testing Tools) شيوعاً

هناك العديد من الأدوات الآلية التي تساعد على إجراء اختبارات الوحدات (Unit Tests) في عملية اختبار البرمجيات.  
كل أداة منها مخصصة للغة أو بيئة معينة، لكنها جميعاً تشترك في هدف واحد: **ضمان أن كل جزء صغير من الكود يعمل كما هو متوقع.**

---

### ☕ **JUnit**
- أداة مجانية ومفتوحة المصدر تُستخدم لاختبار التطبيقات المكتوبة بلغة **Java**.  
- تتيح كتابة اختبارات باستخدام ما يُعرف بـ **Assertions** (تعبيرات تحقق) لتأكيد صحة النتائج.  
- من ميزاتها أنها تختبر البيانات أولاً ثم تُدرجها في الكود للتحقق من سلوك البرنامج.  
- تُستخدم على نطاق واسع في بيئات تطوير Java مثل Eclipse و IntelliJ IDEA.

---

### 🧩 **NUnit**
- إطار اختبار شهير ومفتوح المصدر للغات **.NET** مثل C# و VB.NET.  
- يسمح بكتابة سكربتات الاختبار يدويًا بطريقة منظمة وسهلة القراءة.  
- يدعم **الاختبارات المعتمدة على البيانات (Data-driven tests)** مما يتيح تشغيل نفس الاختبار بعدة مجموعات من القيم.  
- يمكن تشغيل الاختبارات **بشكل متوازي (Parallel Testing)** لتسريع التنفيذ.

---

### 🐘 **PHPUnit**
- إطار اختبار خاص بلغة **PHP** يُستخدم لاختبار أجزاء الكود الصغيرة (الوحدات) بشكل منفصل.  
- يوفر مجموعة كبيرة من **دوال التحقق (Assertions)** الجاهزة التي تساعد في التأكد من أن النظام يتصرف بالطريقة المتوقعة.  
- يُعد أداة أساسية في مشاريع PHP الاحترافية مثل Laravel و Symfony.

---

## 🌍 أدوات أخرى
هذه الأدوات مجرد أمثلة من بين العديد من الأدوات المتوفرة.  
سواء كنت تستخدم **C، C++، Java، Python، JavaScript، أو Go**، ستجد دائمًا إطار اختبار يناسب لغتك وبيئتك.

> 🧠 الفكرة العامة:  
> بغض النظر عن الأداة التي تختارها، الهدف من اختبار الوحدات واحد — **بناء برنامج موثوق يمكن الوثوق بنتائجه وتطويره بثقة.**

</div>

<div dir="rtl">

## 🧪 تطوير البرمجيات بالاختبار أولاً (Test Driven Development - TDD) وارتباطه باختبار الوحدات (Unit Testing)

### ما هو الـ **TDD**؟
TDD أو **Test Driven Development** هو أسلوب في البرمجة يعتمد على كتابة **الاختبار قبل الكود نفسه**.  
الفكرة أن تبدأ بكتابة اختبار يصف السلوك المطلوب من الوحدة (Unit)، ثم تكتب الكود الذي يجعل هذا الاختبار ينجح.  
وبعدها، تعيد تحسين الكود دون أن تخاف من كسره، لأن الاختبار سيكشف أي خطأ فوراً.

---

### 🔁 دورة حياة TDD باختصار
1. **اكتب اختباراً يفشل** (Red) – لأن الكود لم يُكتب بعد.  
2. **اكتب الحد الأدنى من الكود ليجعل الاختبار ينجح** (Green).  
3. **أعد هيكلة الكود (Refactor)** – حسّن التصميم بدون أن تغيّر السلوك.  
4. كرّر العملية مع كل ميزة جديدة.

---

### 💡 العلاقة بين TDD و Unit Testing
في TDD، **اختبارات الوحدات هي القلب**.  
تُكتب باستخدام **أطر اختبار (Testing Frameworks)** مثل JUnit أو NUnit أو PyTest لتشغيل الاختبارات آليًا كل مرة يتم فيها تعديل الكود.

TDD ليست الوحيدة التي تستخدم اختبارات الوحدات، لكن بدونها لا يمكن تطبيق TDD عملياً.

ما الذي يجلبه TDD لعالم اختبار الوحدات؟
- ✅ **الاختبارات تُكتب قبل الكود** وليس بعده.  
- ⚙️ **اعتماد كبير على أطر الاختبار** لتشغيل الاختبارات آلياً.  
- 🧩 **كل الفئات (Classes)** تُختبر بشكل فردي قبل الدمج.  
- 🔗 **التكامل السريع** بين الوحدات بفضل الاختبارات المستمرة.

---

### 🎯 فوائد TDD
- يشجع على بناء **وحدات صغيرة قابلة للاختبار** وتصميم بسيط وواضح.
- يمنع الإفراط في التعقيد (Over-engineering) — الكود يُكتب فقط لتحقيق اختبار محدد.
- يوفر **شبكة أمان دائمة** عند إعادة هيكلة الكود (Refactoring).
- يساعد على **تقدم تدريجي ومنضبط** في التطوير.

> 🧠 **نصيحة الخبراء:**  
> استخدم TDD عندما تريد تحكماً دقيقاً في التصميم، وتغذية راجعة سريعة أثناء كتابة الكود.

---

## ⚙️ لماذا ندمج اختبارات الوحدات مع CI/CD؟

اختبارات الوحدات تصبح أقوى عندما تُدمج في أنظمة **التكامل المستمر (CI)** و**النشر المستمر (CD)**، مثل GitHub Actions أو Jenkins.

الفكرة أن الاختبارات تعمل تلقائيًا مع كل تعديل في الكود، وتشكل “بوابة جودة” تمنع أي كود مكسور من الوصول إلى الإنتاج.

**أهم الفوائد:**
- ⚡ **تغذية راجعة فورية:** يعرف المطور خلال دقائق إذا تسبب تعديله في كسر النظام.
- 🧱 **كشف الأخطاء مبكراً (Shift-left):** تُكتشف العيوب وقت الـ commit وليس بعد الإطلاق.
- 🛡️ **ثقة في الإصدارات:** النظام لا يُنشر إلا عندما يكون “أخضر” بالكامل.
- 🤝 **سهولة التعاون:** الفرق الكبيرة تدمج تغييراتها بدون تضارب أو مشاكل.

---

## 🧚‍♂️ خرافات عن اختبار الوحدات (Unit Testing Myths)

> ❌ “ما عندي وقت للاختبارات”  
> ❌ “الكود تبعي قوي ما بده اختبار”  

هذه الاعتقادات خطأ تماماً.  
في الواقع، **اختبار الوحدات يسرّع التطوير** لأنه يمنع الأخطاء الصغيرة من التحول إلى كوارث مكلفة لاحقاً.  

بدون اختبارات وحدات، الأخطاء البسيطة تُكتشف فقط في مراحل متقدمة (Integration أو Production) حيث تصعب معالجتها وتأخذ وقتاً أطول.

---

## ✅ مميزات اختبار الوحدات (Advantages)

- يساعد المطورين الجدد على **فهم وظائف كل وحدة** من خلال قراءة الاختبارات نفسها.  
- يجعل **إعادة هيكلة الكود (Refactoring)** آمنة — لأن أي خلل سيظهر فوراً في الاختبارات.  
- يمكنك **اختبار أجزاء من المشروع بشكل منفصل** دون انتظار اكتمال النظام بالكامل.  
- يعتبر أساساً للاختبار اللاحق مثل **الاختبار التراجعي (Regression Testing)**.

---

## ⚠️ عيوب اختبار الوحدات (Disadvantages)

- لا يمكنه **كشف جميع الأخطاء** في البرنامج. بعض المسارات التنفيذية تظل غير مغطاة.  
- لا يكتشف **مشاكل التكامل** أو الأخطاء التي تحدث عند تفاعل عدة مكونات معاً.  
- لذلك يُنصح دائماً **باستخدامه مع أنواع أخرى من الاختبار** (Integration, System, Acceptance).

---

## 🧭 أفضل الممارسات في اختبار الوحدات (Best Practices)

1. اجعل كل اختبار **مستقلاً** عن الآخر.  
2. اختبر **وظيفة واحدة فقط** في كل اختبار.  
3. استخدم **أسماء واضحة** توضح السلوك المتوقع (مثلاً: `test_login_fails_with_wrong_password`).  
4. عند تعديل الكود، تأكد أن هناك **اختباراً يغطي التغيير الجديد**.  
5. أصلح جميع الأخطاء المكتشفة قبل الانتقال للمرحلة التالية من الـ SDLC.  
6. اتبع مبدأ **“اختبر وأنت تكتب” (Test as you code)** — لا تكتب كود بدون اختبار.  
7. اعتبر الاختبارات جزءاً من الكود نفسه، واعتنِ بها كما تعتني بالكود الإنتاجي.

> 💬 الفكرة الذهبية:  
> كلما زاد الكود غير المختبَر، زاد احتمال وجود أخطاء غير مكتشفة.  
> اختبارات الوحدات ليست ترفًا — إنها استثمار في وقتك وثقة في كودك.

</div>


