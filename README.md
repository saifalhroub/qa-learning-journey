# qa-learning-journey

## 🧪 الخطوة 4) التشغيل محلياً ثم في CI (Run Locally & in CI)

بعد ما تكتب الاختبارات، شغّلها أولاً على جهازك **محلياً**.  
لما تتأكد إنها شغالة تمام، دمجها في نظام **CI/CD pipeline** (زي GitHub Actions أو Jenkins).  

هيك كل مرة حدا يعدل بالكود، الاختبارات بتشتغل **أوتوماتيكياً** لتتأكد إن ما انكسر شيء.  

### ✅ نصائح:
- خَلّي النتائج **مختصرة وواضحة**.  
- استخدم مبدأ **Fail Fast**: إذا في خطأ، خليه يوقف بسرعة بدل ما يكمّل عالفاضي.  

---

## 🧩 الخطوة 5) تشخيص الفشل، إصلاح، وإعادة هيكلة (Diagnose Failures, Fix, Refactor)

لما اختبار يفشل، أول شيء **حلّل السبب**:  
هل الخطأ من الكود نفسه؟ ولا من الاختبار؟  

بعدها:
- صلّح **مشكلة واحدة فقط في المرة الواحدة**.  
- لما تصير كل الاختبارات “خضراء” ✅، وقتها فيك تعيد **هيكلة الكود (Refactor)** بثقة.  
  الاختبارات هي درعك ضد الأخطاء الجديدة.  

---

## 🔁 الخطوة 6) إعادة التشغيل، المراجعة، والصيانة (Rerun, Review, Maintain)

بعد ما تعمل التعديلات، **شغّل كل الاختبارات مرة ثانية**.  
نظّف الكود والاختبارات:

- احذف الاختبارات المكررة أو غير المفيدة.  
- ميّز الاختبارات البطيئة لتشغيلها أقل.  
- راقب نسبة **Code Coverage** (كم من الكود مغطّى باختبارات).  

> ⚙️ تذكّر: الاختبارات نفسها تحتاج صيانة.  
> إذا صارت هشّة أو بطيئة، لازم تصلحها مثل أي كود ثاني.  

---

## 💡 نصائح سريعة (Pro Tips)

- خَلّي الاختبارات **سريعة ومستقلة**.  
- سمّيها بأسماء توضّح **السلوك المتوقع**، مش التفاصيل التقنية.  
  مثال: `test_total_includes_tax` بدل `test_calc1`.  
- إذا اختبارك أحيانًا ينجح وأحيانًا يفشل، اعتبره **Bug بنفسه** — فقد الموثوقية.  

---

> تحب أضيف كمان فقرة توضح الفرق بين **Mock** و **Stub** بلغة Python وبمثال مصوّر بسيط؟  
> ممكن تكون ممتازة لتكمل هذا القسم في README.
> ## 🧠 What are the Different Unit Testing Techniques?

Unit tests are most effective when they mix **smart test design** with **sensible coverage goals**.  
الفكرة مش إنك توصل 100% تغطية (coverage) بأي ثمن، بل إنك **تركّز على الأجزاء المهمة والخطرة** من النظام.  
ببساطة:
- اعمل اختبارات **واسعة (breadth)** للأجزاء العامة.
- واعمق أكثر في الاختبار **أينما يوجد خطر أعلى** من الأخطاء.
- لا تقع في فخ "100% أو لا شيء" — الكمال الرقمي مش هدف حقيقي.

---

## 🎯 Main Unit Testing Techniques

تقنيات اختبار الوحدات عادةً تُقسم إلى ثلاثة أنواع رئيسية:

### ⚫ 1) Black Box Testing  
تركّز على **المدخلات والمخرجات** فقط دون معرفة كيف يعمل الكود من الداخل.  
يعني تتعامل مع الكود كأنه "صندوق أسود".  
مثلاً:  
لو عندك دالة تحسب ضريبة، تختبر إنها ترجع ناتج صحيح لأي مدخلات، بدون النظر إلى المعادلات بداخلها.  

> 🔹 مفيد لاختبار واجهات المستخدم أو وظائف محددة من منظور المستخدم.

---

### ⚪ 2) White Box Testing  
يعني إنك تختبر **من داخل الكود نفسه** — تعرف كيف الكود مكتوب وتبني اختبارات بناءً على مساراته المنطقية.  
تركّز على:
- تدفق البيانات (data flow)
- الشروط والفروع (conditions and branches)
- التكرارات (loops)

> 🔹 مفيد لاكتشاف أخطاء منطقية داخلية، أو أجزاء الكود التي لا تُنفّذ أبداً.

---

### ⚫⚪ 3) Gray Box Testing  
دمج بين النوعين السابقين.  
المختبر يعرف **بعض التفاصيل الداخلية**، لكن يختبر من **منظور خارجي جزئياً**.  
يُستخدم عادةً في:
- **اختبار التكامل (Integration testing)**  
- **تحليل المخاطر (Risk analysis)**  
- **اختبار الأداء** لبعض المكونات الداخلية.

> 🔹 يوازن بين الفهم الداخلي والدور الخارجي للمستخدم.

---

## 📊 Code Coverage in Unit Testing

**Code Coverage** مش هدف نهائي، بل أداة لتكشف وين عندك نقاط عمياء ما تم اختبارها.  
يعني بدل ما تلاحق رقم، استخدمها لتعرف أين ما زال الكود بدون اختبارات.

### الأنواع الأساسية للتغطية:

#### 🟢 1) Statement Coverage  
يتأكد إن **كل سطر كود** تم تنفيذه على الأقل مرة.

#### 🟡 2) Decision Coverage  
يتأكد إن **كل قرار منطقي (if / else)** تم اختباره في حالتيه (true/false).

#### 🔵 3) Branch Coverage  
يتأكد إن **كل فرع من فروع الكود** تم المرور عليه، حتى الفروع المتداخلة.

#### 🟣 4) Condition Coverage  
يتأكد إن **كل شرط فرعي داخل القرار** تم اختباره (مثلاً كل جزء من if (A && B)).

#### 🟠 5) Finite State Machine Coverage  
يُستخدم للأنظمة التي فيها **حالات متعددة وانتقالات (states & transitions)**، ويتأكد إن كل انتقال محتمل بين الحالات تم اختباره.

---

> 🧩 **الخلاصة:**  
> التغطية العالية ممتازة، لكن الأهم هو أن تكون **الاختبارات ذكية، تغطي ما يهم فعلاً، وتكشف الأخطاء قبل أن تصل للمستخدم.**


