# qa-learning-journey تابع Unit Testing

## 🧪 الخطوة 4) التشغيل محلياً ثم في CI (Run Locally & in CI)

بعد ما تكتب الاختبارات، شغّلها أولاً على جهازك **محلياً**.  
لما تتأكد إنها شغالة تمام، دمجها في نظام **CI/CD pipeline** (زي GitHub Actions أو Jenkins).  

هيك كل مرة حدا يعدل بالكود، الاختبارات بتشتغل **أوتوماتيكياً** لتتأكد إن ما انكسر شيء.  

### ✅ نصائح:
- خَلّي النتائج **مختصرة وواضحة**.  
- استخدم مبدأ **Fail Fast**: إذا في خطأ، خليه يوقف بسرعة بدل ما يكمّل عالفاضي.  

---

## 🧩 الخطوة 5) تشخيص الفشل، إصلاح، وإعادة هيكلة (Diagnose Failures, Fix, Refactor)

لما اختبار يفشل، أول شيء **حلّل السبب**:  
هل الخطأ من الكود نفسه؟ ولا من الاختبار؟  

بعدها:
- صلّح **مشكلة واحدة فقط في المرة الواحدة**.  
- لما تصير كل الاختبارات “خضراء” ✅، وقتها فيك تعيد **هيكلة الكود (Refactor)** بثقة.  
  الاختبارات هي درعك ضد الأخطاء الجديدة.  

---

## 🔁 الخطوة 6) إعادة التشغيل، المراجعة، والصيانة (Rerun, Review, Maintain)

بعد ما تعمل التعديلات، **شغّل كل الاختبارات مرة ثانية**.  
نظّف الكود والاختبارات:

- احذف الاختبارات المكررة أو غير المفيدة.  
- ميّز الاختبارات البطيئة لتشغيلها أقل.  
- راقب نسبة **Code Coverage** (كم من الكود مغطّى باختبارات).  

> ⚙️ تذكّر: الاختبارات نفسها تحتاج صيانة.  
> إذا صارت هشّة أو بطيئة، لازم تصلحها مثل أي كود ثاني.  

---

## 💡 نصائح سريعة (Pro Tips)

- خَلّي الاختبارات **سريعة ومستقلة**.  
- سمّيها بأسماء توضّح **السلوك المتوقع**، مش التفاصيل التقنية.  
  مثال: `test_total_includes_tax` بدل `test_calc1`.  
- إذا اختبارك أحيانًا ينجح وأحيانًا يفشل، اعتبره **Bug بنفسه** — فقد الموثوقية.  

---

> تحب أضيف كمان فقرة توضح الفرق بين **Mock** و **Stub** بلغة Python وبمثال مصوّر بسيط؟  
> ممكن تكون ممتازة لتكمل هذا القسم في README.
> ## 🧠 What are the Different Unit Testing Techniques?

Unit tests are most effective when they mix **smart test design** with **sensible coverage goals**.  
الفكرة مش إنك توصل 100% تغطية (coverage) بأي ثمن، بل إنك **تركّز على الأجزاء المهمة والخطرة** من النظام.  
ببساطة:
- اعمل اختبارات **واسعة (breadth)** للأجزاء العامة.
- واعمق أكثر في الاختبار **أينما يوجد خطر أعلى** من الأخطاء.
- لا تقع في فخ "100% أو لا شيء" — الكمال الرقمي مش هدف حقيقي.

---

## 🎯 Main Unit Testing Techniques

تقنيات اختبار الوحدات عادةً تُقسم إلى ثلاثة أنواع رئيسية:

### ⚫ 1) Black Box Testing  
تركّز على **المدخلات والمخرجات** فقط دون معرفة كيف يعمل الكود من الداخل.  
يعني تتعامل مع الكود كأنه "صندوق أسود".  
مثلاً:  
لو عندك دالة تحسب ضريبة، تختبر إنها ترجع ناتج صحيح لأي مدخلات، بدون النظر إلى المعادلات بداخلها.  

> 🔹 مفيد لاختبار واجهات المستخدم أو وظائف محددة من منظور المستخدم.

---

### ⚪ 2) White Box Testing  
يعني إنك تختبر **من داخل الكود نفسه** — تعرف كيف الكود مكتوب وتبني اختبارات بناءً على مساراته المنطقية.  
تركّز على:
- تدفق البيانات (data flow)
- الشروط والفروع (conditions and branches)
- التكرارات (loops)

> 🔹 مفيد لاكتشاف أخطاء منطقية داخلية، أو أجزاء الكود التي لا تُنفّذ أبداً.

---

### ⚫⚪ 3) Gray Box Testing  
دمج بين النوعين السابقين.  
المختبر يعرف **بعض التفاصيل الداخلية**، لكن يختبر من **منظور خارجي جزئياً**.  
يُستخدم عادةً في:
- **اختبار التكامل (Integration testing)**  
- **تحليل المخاطر (Risk analysis)**  
- **اختبار الأداء** لبعض المكونات الداخلية.

> 🔹 يوازن بين الفهم الداخلي والدور الخارجي للمستخدم.

---

## 📊 Code Coverage in Unit Testing

**Code Coverage** مش هدف نهائي، بل أداة لتكشف وين عندك نقاط عمياء ما تم اختبارها.  
يعني بدل ما تلاحق رقم، استخدمها لتعرف أين ما زال الكود بدون اختبارات.

### الأنواع الأساسية للتغطية:

#### 🟢 1) Statement Coverage  
يتأكد إن **كل سطر كود** تم تنفيذه على الأقل مرة.

#### 🟡 2) Decision Coverage  
يتأكد إن **كل قرار منطقي (if / else)** تم اختباره في حالتيه (true/false).

#### 🔵 3) Branch Coverage  
يتأكد إن **كل فرع من فروع الكود** تم المرور عليه، حتى الفروع المتداخلة.

#### 🟣 4) Condition Coverage  
يتأكد إن **كل شرط فرعي داخل القرار** تم اختباره (مثلاً كل جزء من if (A && B)).

#### 🟠 5) Finite State Machine Coverage  
يُستخدم للأنظمة التي فيها **حالات متعددة وانتقالات (states & transitions)**، ويتأكد إن كل انتقال محتمل بين الحالات تم اختباره.

---

> 🧩 **الخلاصة:**  
> التغطية العالية ممتازة، لكن الأهم هو أن تكون **الاختبارات ذكية، تغطي ما يهم فعلاً، وتكشف الأخطاء قبل أن تصل للمستخدم.**
> <div dir="rtl">

## 🧩 ما هو دور الـ Mocking والـ Stubbing في اختبار الوحدات (Unit Testing)

في اختبار الوحدات، الهدف إنك تختبر **الوحدة البرمجية نفسها** بدون التأثر بأي تبعيات خارجية مثل قاعدة البيانات أو الشبكة أو نظام الملفات.  
وهون بيجي دور **Mocks** و**Stubs** — والمعروفين باسم **Test Doubles** — لاستبدال الكائنات الحقيقية مؤقتًا أثناء الاختبار.

---

## 🎯 لماذا نستخدم Test Doubles؟

الغاية منها **العزل (Isolation)** و**التحكم (Control)**، بحيث تكون اختباراتك دقيقة، سريعة، ويمكن إعادة تشغيلها بثبات.

- **العزل (Isolation):** تختبر الكود نفسه فقط بدون قاعدة بيانات أو API فعلي.  
- **الثبات (Determinism):** تتحكم بالنتائج حتى تكون متوقعة ومضمونة كل مرة.  
- **السرعة (Speed):** الاختبارات بتخلص بسرعة لأنك ما تتعامل مع أنظمة خارجية بطيئة.  
- **محاكاة الحالات النادرة (Edge Case Simulation):** تقدر تحاكي أخطاء زي انتهاء مهلة الـ API أو فشل الاتصال بسهولة.

---

## 🧱 الـ Stubs

الـ **Stub** هو نسخة مبسطة من كائن حقيقي، وظيفتها **إرجاع قيم جاهزة فقط**.  
ما بتسجل التفاعلات، بل تعطي رد ثابت لاختبار المنطق الداخلي للكود.

### 🧪 مثال (Python):

```python
def get_user_from_db(user_id):
    # تخيل هنا استدعاء فعلي لقاعدة البيانات
    raise NotImplementedError()

def test_returns_user_with_stub(monkeypatch):
    # Arrange: إنشاء stub بدلاً من قاعدة البيانات
    monkeypatch.setattr("app.get_user_from_db", lambda _: {"id": 1, "name": "Alice"})
    # Act
    user = get_user_from_db(1)
    # Assert
    assert user["name"] == "Alice"

<div dir="rtl">
```

## 🧰 أكثر أدوات اختبار الوحدات (Unit Testing Tools) شيوعاً

هناك العديد من الأدوات الآلية التي تساعد على إجراء اختبارات الوحدات (Unit Tests) في عملية اختبار البرمجيات.  
كل أداة منها مخصصة للغة أو بيئة معينة، لكنها جميعاً تشترك في هدف واحد: **ضمان أن كل جزء صغير من الكود يعمل كما هو متوقع.**

---

### ☕ **JUnit**
- أداة مجانية ومفتوحة المصدر تُستخدم لاختبار التطبيقات المكتوبة بلغة **Java**.  
- تتيح كتابة اختبارات باستخدام ما يُعرف بـ **Assertions** (تعبيرات تحقق) لتأكيد صحة النتائج.  
- من ميزاتها أنها تختبر البيانات أولاً ثم تُدرجها في الكود للتحقق من سلوك البرنامج.  
- تُستخدم على نطاق واسع في بيئات تطوير Java مثل Eclipse و IntelliJ IDEA.

---

### 🧩 **NUnit**
- إطار اختبار شهير ومفتوح المصدر للغات **.NET** مثل C# و VB.NET.  
- يسمح بكتابة سكربتات الاختبار يدويًا بطريقة منظمة وسهلة القراءة.  
- يدعم **الاختبارات المعتمدة على البيانات (Data-driven tests)** مما يتيح تشغيل نفس الاختبار بعدة مجموعات من القيم.  
- يمكن تشغيل الاختبارات **بشكل متوازي (Parallel Testing)** لتسريع التنفيذ.

---

### 🐘 **PHPUnit**
- إطار اختبار خاص بلغة **PHP** يُستخدم لاختبار أجزاء الكود الصغيرة (الوحدات) بشكل منفصل.  
- يوفر مجموعة كبيرة من **دوال التحقق (Assertions)** الجاهزة التي تساعد في التأكد من أن النظام يتصرف بالطريقة المتوقعة.  
- يُعد أداة أساسية في مشاريع PHP الاحترافية مثل Laravel و Symfony.

---

## 🌍 أدوات أخرى
هذه الأدوات مجرد أمثلة من بين العديد من الأدوات المتوفرة.  
سواء كنت تستخدم **C، C++، Java، Python، JavaScript، أو Go**، ستجد دائمًا إطار اختبار يناسب لغتك وبيئتك.

> 🧠 الفكرة العامة:  
> بغض النظر عن الأداة التي تختارها، الهدف من اختبار الوحدات واحد — **بناء برنامج موثوق يمكن الوثوق بنتائجه وتطويره بثقة.**

</div>



