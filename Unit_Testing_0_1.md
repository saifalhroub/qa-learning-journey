
## تابع Unit Testing
### 🧪 الخطوة 4) التشغيل محلياً ثم في CI (Run Locally & in CI)

بعد ما تكتب الاختبارات، شغّلها أولاً على جهازك **محلياً**.  
لما تتأكد إنها شغالة تمام، دمجها في نظام **CI/CD pipeline** (زي GitHub Actions أو Jenkins).  

هيك كل مرة حدا يعدل بالكود، الاختبارات بتشتغل **أوتوماتيكياً** لتتأكد إن ما انكسر شيء. 

### ✅ نصائح:
- خَلّي النتائج **مختصرة وواضحة**.  
- استخدم مبدأ **Fail Fast**: إذا في خطأ، خليه يوقف بسرعة بدل ما يكمّل عالفاضي.



---

### 🧩 الخطوة 5) تشخيص الفشل، إصلاح، وإعادة هيكلة (Diagnose Failures, Fix, Refactor)

لما اختبار يفشل، أول شيء **حلّل السبب**:  
هل الخطأ من الكود نفسه؟ ولا من الاختبار؟  

بعدها:
- صلّح **مشكلة واحدة فقط في المرة الواحدة**.  
- لما تصير كل الاختبارات “خضراء” ✅، وقتها فيك تعيد **هيكلة الكود (Refactor)** بثقة.  
  الاختبارات هي درعك ضد الأخطاء الجديدة.  

---

### 🔁 الخطوة 6) إعادة التشغيل، المراجعة، والصيانة (Rerun, Review, Maintain)

بعد ما تعمل التعديلات، **شغّل كل الاختبارات مرة ثانية**.  
نظّف الكود والاختبارات:

- احذف الاختبارات المكررة أو غير المفيدة.  
- ميّز الاختبارات البطيئة لتشغيلها أقل.  
- راقب نسبة **Code Coverage** (كم من الكود مغطّى باختبارات).  

> ⚙️ تذكّر: الاختبارات نفسها تحتاج صيانة.  
> إذا صارت هشّة أو بطيئة، لازم تصلحها مثل أي كود ثاني.  

---

### 💡 نصائح سريعة (Pro Tips)

- خَلّي الاختبارات **سريعة ومستقلة**.  
- سمّيها بأسماء توضّح **السلوك المتوقع**، مش التفاصيل التقنية.  
  مثال: `test_total_includes_tax` بدل `test_calc1`.  
- إذا اختبارك أحيانًا ينجح وأحيانًا يفشل، اعتبره **Bug بنفسه** — فقد الموثوقية.  

---

.
> ### 🧠 What are the Different Unit Testing Techniques?

Unit tests are most effective when they mix **smart test design** with **sensible coverage goals**.  
الفكرة مش إنك توصل 100% تغطية بأي ثمن، بل إنك **تركّز على الأجزاء المهمة والخطرة** من النظام.  
ببساطة:
- اعمل اختبارات **واسعة (breadth)** للأجزاء العامة.
- واعمق أكثر في الاختبار **أينما يوجد خطر أعلى** من الأخطاء.
- لا تقع في فخ "100% أو لا شيء" — الكمال الرقمي مش هدف حقيقي.

---

## 🎯 Main Unit Testing Techniques

تقنيات اختبار الوحدات عادةً تُقسم إلى ثلاثة أنواع رئيسية:

### ⚫ 1) Black Box Testing  
تركّز على **المدخلات والمخرجات** فقط دون معرفة كيف يعمل الكود من الداخل.  
يعني تتعامل مع الكود كأنه "صندوق أسود".  
مثلاً:  
لو عندك دالة تحسب ضريبة، تختبر إنها ترجع ناتج صحيح لأي مدخلات، بدون النظر إلى المعادلات بداخلها.  

> 🔹 مفيد لاختبار واجهات المستخدم أو وظائف محددة من منظور المستخدم.

---

### ⚪ 2) White Box Testing  
يعني إنك تختبر **من داخل الكود نفسه** — تعرف كيف الكود مكتوب وتبني اختبارات بناءً على مساراته المنطقية.  
تركّز على:
- تدفق البيانات (data flow); اي اختبار كيفية انتقال البيانات داخل البرنامج
- الشروط والفروع (conditions and branches); اختبار جميع المسارات الممكنة في الشفيرة الناتجة عن التعليمات الشرطية If, Else, Switch
- التكرارات (loops); تركز على اختبار الحلقات التكرارية مثل For, While, do-while

> 🔹 مفيد لاكتشاف أخطاء منطقية داخلية، أو أجزاء الكود التي لا تُنفّذ أبداً.

---

### ⚫⚪ 3) Gray Box Testing  
دمج بين النوعين السابقين.  
المختبر يعرف **بعض التفاصيل الداخلية**، لكن يختبر من **منظور خارجي جزئياً**.  
يُستخدم عادةً في:
- **اختبار التكامل (Integration testing)** للتأكد من ان مكونات النظام تعمل معاً كوحدة واحدة بشكل صحيح 
- **تحليل المخاطر (Risk analysis)** تحديد الاجزاء الاكثر عرضة للاخطاء او الفشل داخل النظام والتكيز عيها اثناء الاختبار 
- **اختبار الأداء** لبعض المكونات الداخلية. فحص مدى كفاءة وسرعة اداء بعض الاجزاء الداخلية من النظام

> 🔹 يوازن بين الفهم الداخلي والدور الخارجي للمستخدم.

---

## 📊 Code Coverage in Unit Testing

 مش هدف نهائي، بل أداة لتكشف وين عندك نقاط عمياء ما تم اختبارها.  
يعني بدل ما تلاحق رقم، استخدمها لتعرف أين ما زال الكود بدون اختبارات.

### الأنواع الأساسية للتغطية:

#### 🟢 1) Statement Coverage  
يتأكد إن **كل سطر كود** تم تنفيذه على الأقل مرة.

#### 🟡 2) Decision Coverage  
يتأكد إن **كل قرار منطقي (if / else)** تم اختباره في حالتيه (true/false).

#### 🔵 3) Branch Coverage  
يتأكد إن **كل فرع من فروع الكود** تم المرور عليه، حتى الفروع المتداخلة.

#### 🟣 4) Condition Coverage  
يتأكد إن **كل شرط فرعي داخل القرار** تم اختباره (مثلاً كل جزء من if (A && B)).

#### 🟠 5) Finite State Machine Coverage  
يُستخدم للأنظمة التي فيها **حالات متعددة وانتقالات (states & transitions)**، ويتأكد إن كل انتقال محتمل بين الحالات تم اختباره.

---

> 🧩 **الخلاصة:**  
> التغطية العالية ممتازة، لكن الأهم هو أن تكون **الاختبارات ذكية، تغطي ما يهم فعلاً، وتكشف الأخطاء قبل أن تصل للمستخدم.**
> <div dir="rtl">

## 🧩 ما هو دور الـ Mocking والـ Stubbing في اختبار الوحدات (Unit Testing)

في اختبار الوحدات، الهدف إنك تختبر **الوحدة البرمجية نفسها** بدون التأثر بأي تبعيات خارجية مثل قاعدة البيانات أو الشبكة أو نظام الملفات.  
وهون بيجي دور **Mocks** و**Stubs** — والمعروفين باسم **Test Doubles** — لاستبدال الكائنات الحقيقية مؤقتًا أثناء الاختبار.

---

## 🎯 لماذا نستخدم Test Doubles؟

الغاية منها **العزل (Isolation)** و**التحكم (Control)**، بحيث تكون اختباراتك دقيقة، سريعة، ويمكن إعادة تشغيلها بثبات.

- **العزل (Isolation):** تختبر الكود نفسه فقط بدون قاعدة بيانات أو API فعلي.  
- **الثبات (Determinism):** تتحكم بالنتائج حتى تكون متوقعة ومضمونة كل مرة.  
- **السرعة (Speed):** الاختبارات بتخلص بسرعة لأنك ما تتعامل مع أنظمة خارجية بطيئة.  
- **محاكاة الحالات النادرة (Edge Case Simulation):** تقدر تحاكي أخطاء زي انتهاء مهلة الـ API أو فشل الاتصال بسهولة.

---

## 🧱 الـ Stubs

الـ **Stub** هو نسخة مبسطة من كائن حقيقي، وظيفتها **إرجاع قيم جاهزة فقط**.  
ما بتسجل التفاعلات، بل تعطي رد ثابت لاختبار المنطق الداخلي للكود.

### 🧪 مثال (Python):

```python
def get_user_from_db(user_id):
    # تخيل هنا استدعاء فعلي لقاعدة البيانات
    raise NotImplementedError()

def test_returns_user_with_stub(monkeypatch):
    # Arrange: إنشاء stub بدلاً من قاعدة البيانات
    monkeypatch.setattr("app.get_user_from_db", lambda _: {"id": 1, "name": "Alice"})
    # Act
    user = get_user_from_db(1)
    # Assert
    assert user["name"] == "Alice"

<div dir="rtl">
```

## 🧰 أكثر أدوات اختبار الوحدات (Unit Testing Tools) شيوعاً

هناك العديد من الأدوات الآلية التي تساعد على إجراء اختبارات الوحدات (Unit Tests) في عملية اختبار البرمجيات.  
كل أداة منها مخصصة للغة أو بيئة معينة، لكنها جميعاً تشترك في هدف واحد: **ضمان أن كل جزء صغير من الكود يعمل كما هو متوقع.**

---

### ☕ **JUnit**
- أداة مجانية ومفتوحة المصدر تُستخدم لاختبار التطبيقات المكتوبة بلغة **Java**.  
- تتيح كتابة اختبارات باستخدام ما يُعرف بـ **Assertions** (تعبيرات تحقق) لتأكيد صحة النتائج.  
- من ميزاتها أنها تختبر البيانات أولاً ثم تُدرجها في الكود للتحقق من سلوك البرنامج.  
- تُستخدم على نطاق واسع في بيئات تطوير Java مثل Eclipse و IntelliJ IDEA.

---

### 🧩 **NUnit**
- إطار اختبار شهير ومفتوح المصدر للغات **.NET** مثل C# و VB.NET.  
- يسمح بكتابة سكربتات الاختبار يدويًا بطريقة منظمة وسهلة القراءة.  
- يدعم **الاختبارات المعتمدة على البيانات (Data-driven tests)** مما يتيح تشغيل نفس الاختبار بعدة مجموعات من القيم.  
- يمكن تشغيل الاختبارات **بشكل متوازي (Parallel Testing)** لتسريع التنفيذ.

---

### 🐘 **PHPUnit**
- إطار اختبار خاص بلغة **PHP** يُستخدم لاختبار أجزاء الكود الصغيرة (الوحدات) بشكل منفصل.  
- يوفر مجموعة كبيرة من **دوال التحقق (Assertions)** الجاهزة التي تساعد في التأكد من أن النظام يتصرف بالطريقة المتوقعة.  
- يُعد أداة أساسية في مشاريع PHP الاحترافية مثل Laravel و Symfony.

---

## 🌍 أدوات أخرى
هذه الأدوات مجرد أمثلة من بين العديد من الأدوات المتوفرة.  
سواء كنت تستخدم **C، C++، Java، Python، JavaScript، أو Go**، ستجد دائمًا إطار اختبار يناسب لغتك وبيئتك.

> 🧠 الفكرة العامة:  
> بغض النظر عن الأداة التي تختارها، الهدف من اختبار الوحدات واحد — **بناء برنامج موثوق يمكن الوثوق بنتائجه وتطويره بثقة.**

</div>

<div dir="rtl">

## 🧪 تطوير البرمجيات بالاختبار أولاً (Test Driven Development - TDD) وارتباطه باختبار الوحدات (Unit Testing)

### ما هو الـ **TDD**؟
** هو أسلوب في البرمجة يعتمد على كتابة **الاختبار قبل الكود نفسه**.  
الفكرة أن تبدأ بكتابة اختبار يصف السلوك المطلوب من الوحدة (Unit)، ثم تكتب الكود الذي يجعل هذا الاختبار ينجح.  
وبعدها، تعيد تحسين الكود دون أن تخاف من كسره، لأن الاختبار سيكشف أي خطأ فوراً.

---

### 🔁 دورة حياة TDD باختصار
1. **اكتب اختباراً يفشل** (Red) – لأن الكود لم يُكتب بعد.  
2. **اكتب الحد الأدنى من الكود ليجعل الاختبار ينجح** (Green).  
3. **أعد هيكلة الكود (Refactor)** – حسّن التصميم بدون أن تغيّر السلوك.  
4. كرّر العملية مع كل ميزة جديدة.

---

### 💡 العلاقة بين TDD و Unit Testing
في TDD، **اختبارات الوحدات هي القلب**.  
تُكتب باستخدام **أطر اختبار (Testing Frameworks)** مثل JUnit أو NUnit أو PyTest لتشغيل الاختبارات آليًا كل مرة يتم فيها تعديل الكود.

 ليست الوحيدة التي تستخدم اختبارات الوحدات، لكن بدونها لا يمكن تطبيق TDD عملياً.

ما الذي يجلبه TDD لعالم اختبار الوحدات؟
- ✅ **الاختبارات تُكتب قبل الكود** وليس بعده.  
- ⚙️ **اعتماد كبير على أطر الاختبار** لتشغيل الاختبارات آلياً.  
- 🧩 **كل الفئات (Classes)** تُختبر بشكل فردي قبل الدمج.  
- 🔗 **التكامل السريع** بين الوحدات بفضل الاختبارات المستمرة.

---

### 🎯 فوائد TDD
- يشجع على بناء **وحدات صغيرة قابلة للاختبار** وتصميم بسيط وواضح.
- يمنع الإفراط في التعقيد (Over-engineering) — الكود يُكتب فقط لتحقيق اختبار محدد.
- يوفر **شبكة أمان دائمة** عند إعادة هيكلة الكود (Refactoring).
- يساعد على **تقدم تدريجي ومنضبط** في التطوير.

> 🧠 **نصيحة الخبراء:**  
> استخدم TDD عندما تريد تحكماً دقيقاً في التصميم، وتغذية راجعة سريعة أثناء كتابة الكود.

---

## ⚙️ لماذا ندمج اختبارات الوحدات مع CI/CD؟

اختبارات الوحدات تصبح أقوى عندما تُدمج في أنظمة **التكامل المستمر (CI)** و**النشر المستمر (CD)**، مثل GitHub Actions أو Jenkins.

الفكرة أن الاختبارات تعمل تلقائيًا مع كل تعديل في الكود، وتشكل “بوابة جودة” تمنع أي كود مكسور من الوصول إلى الإنتاج.

**أهم الفوائد:**
- ⚡ **تغذية راجعة فورية:** يعرف المطور خلال دقائق إذا تسبب تعديله في كسر النظام.
- 🧱 **كشف الأخطاء مبكراً (Shift-left):** تُكتشف العيوب وقت الـ commit وليس بعد الإطلاق.
- 🛡️ **ثقة في الإصدارات:** النظام لا يُنشر إلا عندما يكون “أخضر” بالكامل.
- 🤝 **سهولة التعاون:** الفرق الكبيرة تدمج تغييراتها بدون تضارب أو مشاكل.

---

## 🧚‍♂️ خرافات عن اختبار الوحدات (Unit Testing Myths)

> ❌ “ما عندي وقت للاختبارات”  
> ❌ “الكود تبعي قوي ما بده اختبار”  

هذه الاعتقادات خطأ تماماً.  
في الواقع، **اختبار الوحدات يسرّع التطوير** لأنه يمنع الأخطاء الصغيرة من التحول إلى كوارث مكلفة لاحقاً.  

بدون اختبارات وحدات، الأخطاء البسيطة تُكتشف فقط في مراحل متقدمة (Integration أو Production) حيث تصعب معالجتها وتأخذ وقتاً أطول.

---

## ✅ مميزات اختبار الوحدات (Advantages)

- يساعد المطورين الجدد على **فهم وظائف كل وحدة** من خلال قراءة الاختبارات نفسها.  
- يجعل **إعادة هيكلة الكود (Refactoring)** آمنة — لأن أي خلل سيظهر فوراً في الاختبارات.  
- يمكنك **اختبار أجزاء من المشروع بشكل منفصل** دون انتظار اكتمال النظام بالكامل.  
- يعتبر أساساً للاختبار اللاحق مثل **الاختبار التراجعي (Regression Testing)**.

---

## ⚠️ عيوب اختبار الوحدات (Disadvantages)

- لا يمكنه **كشف جميع الأخطاء** في البرنامج. بعض المسارات التنفيذية تظل غير مغطاة.  
- لا يكتشف **مشاكل التكامل** أو الأخطاء التي تحدث عند تفاعل عدة مكونات معاً.  
- لذلك يُنصح دائماً **باستخدامه مع أنواع أخرى من الاختبار** (Integration, System, Acceptance).

---

## 🧭 أفضل الممارسات في اختبار الوحدات (Best Practices)

1. اجعل كل اختبار **مستقلاً** عن الآخر.  
2. اختبر **وظيفة واحدة فقط** في كل اختبار.  
3. استخدم **أسماء واضحة** توضح السلوك المتوقع (مثلاً: `test_login_fails_with_wrong_password`).  
4. عند تعديل الكود، تأكد أن هناك **اختباراً يغطي التغيير الجديد**.  
5. أصلح جميع الأخطاء المكتشفة قبل الانتقال للمرحلة التالية من الـ SDLC.  
6. اتبع مبدأ **“اختبر وأنت تكتب” (Test as you code)** — لا تكتب كود بدون اختبار.  
7. اعتبر الاختبارات جزءاً من الكود نفسه، واعتنِ بها كما تعتني بالكود الإنتاجي.
</div>
> 💬 الفكرة الذهبية:  
> كلما زاد الكود غير المختبَر، زاد احتمال وجود أخطاء غير مكتشفة.  
> اختبارات الوحدات ليست ترفًا — إنها استثمار في وقتك وثقة في كودك.

<h3 dir="rtl">📘 الملخص (Summary)</h3>

<p dir="rtl">
اختبار الوحدات (Unit Testing) هو الأساس الحقيقي لجودة البرمجيات الحديثة.  
من خلال التحقق من الكود على أصغر مستوى، يمنع انتشار الأخطاء، ويسرّع عملية التطوير، ويمنح الفرق ثقة أكبر في إطلاق منتجاتها بسرعة وأمان.
</p>

<p dir="rtl">
وعندما يُدمج مع ممارسات مجرّبة مثل نموذج <b>AAA (Arrange – Act – Assert)</b>  
وتقنيات الاختبار الذكية، وأهداف التغطية المنطقية، والتكامل المستمر <b>(CI/CD)</b>،  
يتحوّل اختبار الوحدة من مجرد فحص للكود إلى شبكة أمان حية تتطور مع المشروع.
</p>

<p dir="rtl">
لكن التوازن هو المفتاح.  
تجنّب الإفراط في اختبار الأكواد البسيطة أو الاعتماد الزائد على المحاكاة (Mocking)،  
أو مطاردة مؤشرات وهمية مثل “تغطية 100%”.  
بدل ذلك، ركّز الجهد على منطق الأعمال الأساسي، والمكوّنات القابلة لإعادة الاستخدام،  
والمناطق عالية الخطورة — حيث تقدم الاختبارات أفضل عائد حقيقي.
</p>

<p dir="rtl">
باختصار، اختبار الوحدة مش مجرد كتابة اختبارات،  
بل هو بناء <b>ثقافة ثقة وصيانة مستمرة وتحسين دائم</b>.  
الفرق التي تستثمر فيه تجني مكاسب طويلة المدى: أخطاء أقل، كود أنظف، وإصدارات أكثر سلاسة.
</p>

<div dir="rtl">

# 🧩 أنواع اختبار الوحدات (Unit Testing)

يُعتبر **Unit Testing** جزءاً أساسياً من عملية اختبار البرمجيات، ويهدف إلى اختبار كل جزء صغير من الكود (وحدة) بشكل منفصل لضمان أنه يعمل كما يجب.

---

## 📖 أنواع اختبار الوحدات

يُقسم اختبار الوحدات إلى نوعين رئيسيين، يختلف كل منهما في الأسلوب والتطبيق:

### 🔹 Manual Unit Testing

الاختبار اليدوي يمثل نهجاً عملياً يعتمد على كتابة وتنفيذ حالات الاختبار يدويًا، دون استخدام أدوات أتمتة.  
يُعد هذا النوع أكثر مرونة في بعض الحالات، لكنه عادةً أبطأ وأكثر عرضة للأخطاء البشرية.

#### ✅ مميزات Manual Unit Testing

- يوفر دقة عالية في الحالات التي تتطلب الحدس والفهم البشري.
- يسمح للمختبر بالتفاعل المباشر مع النظام بطرق لا تستطيع الأتمتة تنفيذها.
- يمنح مرونة أكبر خصوصاً في المراحل الأولى من التطوير.
- لا يحتاج إلى أدوات أو أُطر اختبار معقدة، مما يجعله مناسباً للفرق الصغيرة أو المشاريع محدودة الموارد.

#### ❌ عيوب Manual Unit Testing

- بطيء مقارنة بالأتمتة، خصوصاً في المشاريع الكبيرة.
- يعتمد على مهارة ودقة المختبر، ما قد يؤدي إلى نتائج غير متناسقة.
- قد يكون مكلفاً على المدى الطويل بسبب الحاجة المستمرة للمختبرين.
- صعوبة التكرار والاتساق في النتائج.

---

### 🤖 Automated Unit Testing

في هذا النوع، يتم تنفيذ الاختبارات باستخدام أدوات برمجية بدلاً من العملية اليدوية.  
يُعد هذا النهج جزءاً أساسياً من **Test-Driven Development (TDD)**، ويوفر سرعة، اتساقاً، وإمكانية دمج عالية مع عملية التطوير.

#### ✅ مميزات Automated Unit Testing

- تنفيذ سريع ومتكرر للاختبارات، ما يوفر الوقت في المشاريع الكبيرة.
- يمنع التفاوت الناتج عن الخطأ البشري، مما يعزز الموثوقية.
- قابل للتكامل مع أنظمة **Continuous Integration / Continuous Deployment (CI/CD)**.
- يقلل من التكاليف والوقت على المدى الطويل بعد إعداد الإطار الأساسي.
- يسهل اكتشاف العيوب في مراحل مبكرة من التطوير.

#### ❌ عيوب Automated Unit Testing

- يحتاج إلى وقت وخبرة لإعداد البيئة وأدوات الأتمتة.
- قد يكون مكلفاً في المشاريع الصغيرة.
- أقل مرونة من الاختبارات اليدوية، لأنها تتبع خطوات محددة مسبقاً.
- يتطلب صيانة مستمرة في حال تغيّر الكود أو واجهات النظام.

---

## 🧠 تصنيف اختبارات الوحدات حسب الاستراتيجية

بعيداً عن كون الاختبار يدوياً أو آلياً، هناك استراتيجيات مختلفة لتطبيق اختبارات الوحدات.  
تشمل هذه: **الاختبار الأبيض (White Box)**، **الاختبار الأسود (Black Box)**، و**الاختبار الرمادي (Gray Box)**.

---

### ⚪ White Box Testing

ويُعرف أيضاً باسم *Clear Box* أو *Transparent Testing*.  
يركز هذا الأسلوب على **اختبار البنية الداخلية للكود** بدلاً من وظائفه الخارجية.  
يتطلب معرفة تفصيلية بالكود ومهارات برمجية لتصميم حالات الاختبار.

#### ✅ المميزات

- يتيح اختبار المسارات المنطقية الداخلية بدقة.
- يساعد على تحسين الأداء واكتشاف الأخطاء العميقة في الكود.
- يسهّل تحسين جودة الكود البرمجي وزيادة كفاءته.
- يوفر فهماً شاملاً لآلية عمل التطبيق الداخلية.

#### ❌ العيوب

- معقد ويستغرق وقتاً طويلاً.
- يحتاج إلى مطورين ذوي خبرة عالية.
- لا يكشف عن الوظائف المفقودة أو غير المنفذة.

---

### ⚫ Black Box Testing

في هذا النوع، لا يعرف المختبِر شيئاً عن البنية الداخلية للتطبيق.  
يركّز على **المدخلات والمخرجات** فقط: ما الذي يُدخَل للنظام، وما النتائج التي ينتجها.

#### ✅ المميزات

- لا يحتاج المختبر إلى معرفة بالكود أو لغة البرمجة.
- ممتاز لاختبار الواجهات الأمامية وتجربة المستخدم.
- يتحقق من مطابقة التطبيق للمتطلبات الوظيفية.

#### ❌ العيوب

- لا يمكنه كشف الأخطاء داخل الكود نفسه.
- محدود في اختبارات البنية الخلفية (Back-end).

---

### ⚫⚪ Gray Box Testing

يجمع بين ميزات **White Box** و **Black Box**، حيث يعرف المختبِر جزءاً من البنية الداخلية للتطبيق.  
يُستخدم كثيراً في **اختبار الأمان** و **تكامل الأنظمة (Integration Testing)** و **تطبيقات الويب**.

#### ✅ المميزات

- يجمع بين فهم داخلي جزئي وتحليل سلوكي خارجي.
- يسمح بتصميم حالات اختبار أكثر دقة وذكاء.
- مناسب لاختبارات النظم المعقدة.

#### ❌ العيوب

- يتطلب توازناً دقيقاً بين الفهم التقني والتحليل الخارجي.
- قد لا يكون شاملاً مثل White Box أو بسيطاً مثل Black Box.

---

## 🧩 الخلاصة

اختبار الوحدات (Unit Testing) يشمل عدة أنواع واستراتيجيات:  
يدوي، آلي، أبيض، أسود، ورمادي.  
كل نوع منها له ميزاته وتحدياته الخاصة، واختيار الأنسب يعتمد على **هدف المشروع، حجم الفريق، ومرحلة التطوير**.  
تحقيق التوازن بين الدقة البشرية وسرعة الأتمتة هو ما يصنع فرقاً حقيقياً في جودة البرمجيات الحديثة.

</div>

